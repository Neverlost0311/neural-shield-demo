<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Neural Shield Demo — Polished View</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --bg: #020617;
      --status-bg: rgba(0,0,0,0.7);
      --status-ok: #22c55e;
      --status-bad: #ef4444;
      --status-text: #c7f9eb;
    }
    html,body { height:100%; margin:0; }
    body {
      margin: 0;
      overflow: hidden;
      background: var(--bg);
      color: white;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    #status {
      position: absolute;
      top: 18px;
      left: 18px;
      background: var(--status-bg);
      padding: 10px 16px;
      border-radius: 10px;
      font-size: 15px;
      z-index: 100;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      color: var(--status-text);
      box-shadow: 0 6px 18px rgba(0,0,0,0.6);
      transition: transform .35s ease, opacity .35s ease;
      white-space: nowrap;
    }
    #status.hidden { opacity: 0; transform: translateY(-10px); pointer-events:none; }
    #status .dot { width:18px; height:18px; border-radius:6px; display:inline-block; }
    #status .spinner {
      width:14px; height:14px; border-radius:50%;
      border: 2px solid rgba(255,255,255,0.12);
      border-top-color: rgba(255,255,255,0.6);
      animation: spin 1s linear infinite;
      display:inline-block;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* small helpful hint bottom-left */
    #hint {
      position: absolute;
      left: 18px;
      bottom: 18px;
      color: #94a3b8;
      font-size: 12px;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(4px);
      padding: 8px 10px;
      border-radius: 8px;
      z-index: 80;
    }
  </style>
</head>
<body>

  <div id="status"><span class="spinner"></span> <span id="status-text">⌛ Initializing Neural Shield...</span></div>
  <div id="hint">Use mouse drag to rotate (yaw). Zoom & pan are locked for consistent inspection view.</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.152.2/examples/jsm/",
    "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.0.0/lib/three-vrm.module.js"
  }
}
</script>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  import { VRMLoaderPlugin } from '@pixiv/three-vrm';

  // ---------- Core Three.js setup ----------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.5, 2.2);
  camera.lookAt(0, 1.4, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  // OrbitControls tuned for a scanner-like view
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 1.4, 0);
  controls.enableDamping = true;
  controls.dampingFactor = 0.07;
  controls.enablePan = false;        // no panning
  controls.enableZoom = false;       // no zooming so the framing is stable
  // lock polar angle so viewer sees model straight-on (adjust slightly if you want vertical freedom)
  controls.minPolarAngle = Math.PI / 2.2;
  controls.maxPolarAngle = Math.PI / 2.2;
  controls.update();

  // ---------- Improved lighting (key / fill / rim + ambient) ----------
  scene.add(new THREE.AmbientLight(0xffffff, 0.35)); // soft base light

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.1);
  keyLight.position.set(1.5, 2, 2);
  keyLight.castShadow = false;
  scene.add(keyLight);

  const fillLight = new THREE.DirectionalLight(0x88ccff, 0.38);
  fillLight.position.set(-1.5, 1, 1);
  fillLight.castShadow = false;
  scene.add(fillLight);

  const rimLight = new THREE.DirectionalLight(0x00e6c3, 0.8);
  rimLight.position.set(0, 2, -2);
  rimLight.castShadow = false;
  scene.add(rimLight);

  // subtle floor grid for spatial reference (very low contrast)
  const grid = new THREE.GridHelper(12, 24, 0x0b1220, 0x071016);
  grid.position.y = 0.0;
  grid.material.opacity = 0.12;
  grid.material.transparent = true;
  scene.add(grid);

  // ---------- VRM loader setup ----------
  const loader = new GLTFLoader();
  loader.register((parser) => new VRMLoaderPlugin(parser));

  const statusEl = document.getElementById('status');
  const statusTextEl = document.getElementById('status-text');

  function setStatus(text, ok = null) {
    statusTextEl.textContent = text;
    if (ok === true) {
      statusEl.style.border = '1px solid rgba(34,197,94,0.12)';
      statusEl.querySelector('.spinner').style.display = 'none';
      statusTextEl.style.color = 'var(--status-ok)';
      // hide after a short delay
      setTimeout(() => statusEl.classList.add('hidden'), 2000);
    } else if (ok === false) {
      statusEl.querySelector('.spinner').style.display = 'none';
      statusTextEl.style.color = 'var(--status-bad)';
    } else {
      statusTextEl.style.color = 'var(--status-text)';
      statusEl.classList.remove('hidden');
      statusEl.querySelector('.spinner').style.display = 'inline-block';
    }
  }

  setStatus('⌛ Downloading Model...');

  // Keep a handle to the loaded vrm for gentle motion
  let loadedVrm = null;
  let vrmBaseY = 0;

  loader.load(
    './patient.vrm',
    (gltf) => {
      // pixiv/three-vrm attaches VRM to gltf.userData.vrm
      const vrm = gltf.userData.vrm;
      if (!vrm) {
        console.warn('Loaded GLTF does not contain VRM in userData.vrm; adding gltf.scene instead.');
        scene.add(gltf.scene);
        setStatus('✅ Neural Shield: Model Added (non-VRM)', true);
        return;
      }
      // Add VRM scene (keeps original hierarchy; do not modify internals)
      scene.add(vrm.scene);

      // rotate so front faces camera nicely
      vrm.scene.rotation.y = Math.PI;

      // ensure model sits on ground: sample bounding box
      const bbox = new THREE.Box3().setFromObject(vrm.scene);
      const height = bbox.max.y - bbox.min.y;
      vrmBaseY = -bbox.min.y; // so min y maps to 0
      vrm.scene.position.y = vrmBaseY; // place feet at y=0

      loadedVrm = vrm;

      console.log('VRM loaded:', vrm);
      setStatus('✅ Neural Shield: Patient Loaded', true);
    },
    (progress) => {
      // protect against progress.total being 0
      const pct = progress && progress.total ? Math.round(100.0 * (progress.loaded / progress.total)) : null;
      setStatus(pct ? `⌛ Downloading Model... (${pct}%)` : '⌛ Downloading Model...');
      console.log('Loading progress:', progress);
    },
    (error) => {
      console.error('Model load error:', error);
      setStatus('❌ Error loading model — check console', false);
    }
  );

  // ---------- subtle idle motion and animation loop ----------
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);

    const t = clock.getElapsedTime();

    // small scene yaw for subtle cinematic feel
    scene.rotation.y = Math.sin(t * 0.12) * 0.02;

    // gentle VRM breathing and head micro-motion (non-invasive)
    if (loadedVrm && loadedVrm.scene) {
      // small vertical bob
      loadedVrm.scene.position.y = vrmBaseY + Math.sin(t * 1.3) * 0.007;

      // tiny head sway: find a top-level rotation target (safe to rotate whole scene little)
      // (Avoid changing VRM bones directly here to keep logic untouched)
      loadedVrm.scene.rotation.x = Math.sin(t * 0.25) * 0.002;
    }

    // smooth damping for controls
    controls.update();

    renderer.render(scene, camera);
  }
  animate();

  // ---------- Resize handling ----------
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // ---------- small keyboard convenience: R = re-center view ----------
  window.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      controls.reset();
      controls.target.set(0, 1.4, 0);
      camera.position.set(0, 1.5, 2.2);
      camera.lookAt(0, 1.4, 0);
    }
  });
</script>
</body>
</html>
